package main

import (
	_ "alethic-ism-query-api/docs" // Swagger docs (autogenerated) but needs to be imported
	"alethic-ism-query-api/pkg/data"
	"alethic-ism-query-api/pkg/dsl"
	"fmt"
	"github.com/gin-gonic/gin"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
	"log"
	"net/http"
)

var (
	dataAccess *data.Access
)

// @title Alethic ISM - Data Query API
// @version 1.0
// @description This is a query api for Alethic ISM using a storage class: database
// @termsOfService http://swagger.io/terms/

// @contact.name
// @contact.url
// @contact.email

// @license.name Quantum Wake OU - Copyright 2024
// @license.url

// @host localhost:8080
// @BasePath /api/v1/query
func main() {
	dataAccess = data.InitializeNewDataAccessFromEnvDSN()

	gin.SetMode(gin.DebugMode)
	gin.DebugPrintRouteFunc = func(httpMethod, absolutePath, handlerName string, nuHandlers int) {
		fmt.Printf("ROUTE %s %s -> %s (%d handlers)\n", httpMethod, absolutePath, handlerName, nuHandlers)
	}

	r := gin.Default()
	r.Use(gin.Logger())   // Logs each request with details
	r.Use(gin.Recovery()) // Recover from panics and log the error
	r.LoadHTMLGlob("templates/*.html")

	v1 := r.Group("/api/v1/query")
	{
		v1.POST("/state/:id", handleQueryState)
	}

	// Swagger documentation route
	r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	// ReDoc documentation route
	r.GET("/redoc/*any", RedocHandler())

	err := r.Run(":8080")
	if err != nil {
		return
	}
}

// RedocHandler serves ReDoc UI
func RedocHandler() gin.HandlerFunc {
	return func(c *gin.Context) {
		c.HTML(http.StatusOK, "redoc.html", gin.H{
			"SpecURL": "/api/v1/query/swagger/doc.json",
		})
	}
}

// @Summary Query state data
// @Description Query state data with filters
// @Tags State
// @Accept  json
// @Produce  json
// @Param id path string true "State ID"
// @Param dsl.StateQuery body dsl.StateQuery true "the query groups and filters"
// @Success 200 {array} dsl.StateQueryResult
// @Failure 400 {object} model.ErrorResponse
// @Failure 500 {object} model.ErrorResponse
// @Router /api/v1/state/{id} [post]
func handleQueryState(c *gin.Context) {
	stateID := c.Param("id")
	log.Println("querying state data for stateID: ", stateID)

	// Parse JSON body for filter criteria into StateQuery
	var query dsl.StateQuery
	query.UserID = stateID // temporary hardcoding to TODO: get from JWT
	query.StateID = stateID
	if err := c.ShouldBindJSON(&query); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid input"})
		return
	}

	log.Println("querying state data for stateID: ", stateID, " with query: ", query)

	// Execute the query
	results, err := dataAccess.Query(query)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "internal error"})
		return
	}
	log.Println("querying state data for stateID: ", stateID, " with query: ", query, " returned results: ", results)

	// Return the results
	c.JSON(http.StatusOK, results)
}
